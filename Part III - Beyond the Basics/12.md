# Chapter 12. Securing the Kubernetes API server

### 주요 내용

- ...

## 12.1 Understanding authentication

API server 가 요청을 받게 되면, authentication plugin 을 거치며 요청을 보낸 주체가 누구인지 분석한다.

Plugin 을 거치게 되면 username, user ID, 클라이언트가 속하는 group 등의 정보가 API server 에게 전달된다.

### 12.1.1 Users and groups

#### Understanding users

Kubernetes 에서는 API server 에 연결하는 주체를 2가지로 분류한다.

- 사람 (users)
- Pods (정확히는 pod 내에 실행 중인 어플리케이션)

실제 사람과 같은 경우 외부 시스템 (SSO 등) 에 의해 관리된다. (관심 대상이 아니다) 실제 사용자의 계정을 관리하는 리소스는 존재하지 않는다.

한편 pod 의 경우 *service accounts* 를 사용하는데, 이는 클러스터에 ServiceAccount 리소스로 저장된다.

#### Understanding groups

모든 사용자는 하나 혹은 그 이상의 group 에 속할 수 있다. Group 을 사용하게 되면 여러 명의 user 에게 동시에 권한을 줄 수 있다.

Authentication plugin 에서 group 을 알려준다고 했는데, plugin 은 group 을 string 으로 알려준다. 몇 가지의 내장된 group 이 있다.

- `system:unauthenticated`: 모든 authentication plugin 이 요청을 authenticate 할 수 없는 경우
- `system:authenticated`: Authentication 이 성공한 user 에게 자동으로 설정된다
- `system:serviceaccounts`: 시스템(클러스터)에 존재하는 모든 ServiceAccounts 를 포함한다
- `system:serviceaccounts:<namespace>`: 특정 namespace 안의 모든 ServiceAccounts 를 포함한다

### 12.1.2 Introducing ServiceAccounts

Pod 가 API server 와 통신할 때는 `/var/run/secrets/kubernetes.io/serviceaccount/token` 에 있는 token 을 이용해서 authentication 한다는 것을 배웠다. (이 파일은 `secret` volume 을 통해 mount 된다) 이제 이 파일이 정확히 무엇을 의미하는지 알아본다.

모든 pod 는 ServiceAccount 와 연결되게 되는데, 이 token 파일에는 ServiceAccount 의 authentication token 이 들어있다. 그래서 어플리케이션이 token 을 이용해서 API server 와 통신하게 되면, authentication plugin 에서는 해당 ServiceAccount 를 authenticate 하고, API server 에게 ServiceAccount username 을 알려준다.

ServiceAccount username 은 다음과 같은 형식으로 구성되어 있다.

```
system:serviceaccount:<namespace>:<service account name>
```

이제 API server 는 이 ServiceAccount username 을 authorization plugin 에게 넘기고, 요청의 action 을 수행할 권한이 있는지 확인한다.

결국 ServiceAccount 는 pod 내의 어플리케이션이 API server 와의 통신에서 자신을 authenticate 하는 방법이다.

#### Understanding the ServiceAccount resource

ServiceAccount 도 namespace 에 귀속된다.

각 namespace 에는 default ServiceAccount 가 기본적으로 생성되며, pod 들은 이 default ServiceAccount 를 기본적으로 사용한다.

```
$ kubectl get sa 
NAME      SECRETS   AGE
default   1         79d
```

각 pod 는 오직 하나의 ServiceAccount 와 연결될 수 있지만, 같은 ServiceAccount 를 여러 pod 에서 재사용 할 수 있다. 단 제약 조건이 있는데, 같은 namespace 의 ServiceAccount 만 사용할 수 있다.

#### Understanding how ServiceAccounts tie into authorization

Pod manifest 에 ServiceAccount 를 지정하게 되는데, (지정하지 않으면 default 사용) ServiceAccount 마다 역할이 정해져 있기 때문에 pod 의 권한 또한 제어가 가능하다.

API server 가 token 을 받으면 어떤 ServiceAccount 인지 확인하고, 해당 ServiceAccount 의 권한을 확인하여 요청을 수행할 권한이 있는지 확인하게 되는 방식이다.

### 12.1.3 Creating ServiceAccounts

권한 부여는 최소로 하는 것이 원칙이다. 그래서 pod 의 용도에 맞게 ServiceAccount 를 직접 설정하고 pod 에 연결해야한다.

생성은 아래와 같이 하면 된다.

```
$ kubectl create serviceaccount <NAME>
```

이제 `describe` 로 확인해 보면,

```
$ kubectl describe sa foo            
Name:                foo
Namespace:           default
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none>
Mountable secrets:   foo-token-hnx6x
Tokens:              foo-token-hnx6x
Events:              <none>
```

`Tokens: ...` 에 새로운 token이 생성된 것을 확인할 수 있고, 이는 Secret 으로 관리된다.

#### Mountable secrets

원래 pod 는 원하는 Secret 을 임의로 mount 할 수 있다. 하지만 pod 의 ServiceAccount 에서, 이 ServiceAccount 를 사용하는 pod 이 mount 할 수 있는 Secret 을 제한할 수 있다. 

Mountable secrets 목록은 이 pod 가 mount 할 수 있는 Secret 의 목록이다. 다른 Secret 은 사용할 수 없다.

#### Image pull secrets

Image pull secret 은 private image repository 에서 image 를 pull 받을 때 사용하는 credential 이다. Mountable secrets 처럼 사용 가능한 secret 을 제한하는 것은 아니고, image pull secret 에 있는 secret 은 해당 ServiceAccount 를 사용하는 모든 pod 에 자동으로 mount 된다.

### 12.1.4 Assigning a ServiceAccount to a pod

Pod definition 에서 `.spec.serviceAccountName` 필드에 적어주면 된다. Pod 생성할 때 미리 정해야 하며, pod 가 생성된 뒤에는 수정할 수 없다.

---

## Discussion & Additional Topics


