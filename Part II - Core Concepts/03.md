# Chapter 3. Pods: running containers in Kubernetes

다양한 쿠버네티스 오브젝트 (resources) 를 살펴보는 단원이다. 가장 기본이 되는 Pod 부터 시작한다. 이외의 모든 것들은 pod 를 관리하거나, pod 를 노출하거나, pod 에 의해 사용된다.

## 3.1 Introducing Pods

**Pod** 는 컨테이너의 모임이며, 쿠버네티스의 기본적인 building block 이 된다. 하나 기억할 사실은, 하나의 pod 는 하나의 노드 위에 있게 되므로, pod 내부의 모든 컨테이너는 같은 노드에 존재하게 된다.

### 3.1.1 왜 Pod 를 사용하는가?

그냥 하나의 컨테이너 안에서 모든 것을 실행하면 안 되는 것인가?

하나의 프로세스라면 하나의 컨테이너 안에서 실행해도 괜찮지만, 여러 프로세스가 한꺼번에 동작하는 앱의 경우 한 컨테이너 안에서 돌아가게 되면 관리가 어렵다.

모든 프로세스가 정상적으로 돌아가고 있는지 개발자가 직접 확인해야 하고, 프로세스가 죽으면 직접 다시 시작해줘야 하며, 실제 서비스에서 특정 프로세스가 지나친 병목을 일으키는 경우에는 scale out 을 적용하여 해당 프로세스만 여러 개 실행하여 throughput 을 늘릴 수도 있을 것이다.

그러므로 컨테이너를 여러 개 쓰는 것이 보다 바람직하다.

(여러 개 쓰고 이걸 묶으면 pod 가 되는 것)

### 3.1.2 Pod 에 대한 이해

컨테이너 하나에서 여러 프로세스를 실행하는 것은 바람직하지 않으므로, 컨테이너 여러 개를 하나로 묶어서 관리해줄 상위 레벨의 개념이 필요하다. 그래서 Pod 가 등장하게 된 것이다.

#### Pod 내의 partial isolation

Pod 를 사용하면 서로 연관된 프로세스를 실행하는 컨테이너들을 함께 실행할 수 있게 되며, 마치 하나의 머신/컨테이너 안에서 실행되는 것처럼 환경을 제공할 수 있게 된다. 

물론 각 컨테이너도 서로 어느 정도 독립적으로 동작하지만, 같은 pod 내의 container 는 같은 namespace 를 가지고 있고, 또 쿠버네티스 *volume* 을 사용해서 컨테이너들 끼리 파일을 공유하도록 설정할 수도 있다.

#### Shared IP and port space

같은 pod 내의 컨테이너들은 IP 를 공유하므로, 하나의 포트에는 하나의 서비스만 할당되어야 한다. 또 같은 *loopback network interface* 를 사용하므로 localhost 를 사용해 컨테이너들 끼리 통신할 수 있다.

#### Flat inter-pod nework

Pod 마다 IP 가 할당되어 있고, 모든 pod 들은 하나의 flat (network topology 말하는 듯), 공유된 네트워크 주소 공간을 사용한다. 그러므로 pod 들 끼리 서로의 IP 주소를 이용해 통신할 수 있으며, NAT(Network Address Translation) gateway 가 사이에 존재하지 않는다. 이는 pod 가 서로 다른 노드에 배치되더라도 상관없다.

이렇게 동작하기 위해서는 SDN(Software Defined Network) 레이어를 하나 만들어서 사용한다.

#### 요약

Pod 는 논리적인 호스트이며, 컨테이너를 사용하지 않는다면 물리적인 호스트나 VM과 다를바 없다. 한 pod 내의 프로세스들은 같은 머신에서 동작하는 프로세스들이며, 차이점은 각 프로세스가 컨테이너 안에서 돌아간다는 점이다.

### 3.1.3 Pod 내의 컨테이너 배치

Pod 는 개별적인 머신이지만 한 머신이 하나의 앱을 실행한다고 이해해야한다.

Pod 는 가벼우므로 거의 오버헤드 없이 여러 개를 실행할 수 있으므로, 하나의 pod 에 모든 것을 꾸겨 넣기 보다는 여러 개의 pod 를 사용해서 한 pod 내에는 관련이 깊은 작업만 있또록 관리하는 것이 좋다.

#### 하나의 앱을 여러 컨테이너로 분리

백엔드, 프론트엔드가 있는 서비스를 생각해보면, 각각을 하나의 pod 내에 넣지 말라는 법은 없지만 바람직한 방법은 아니다.

만약 쿠버네티스 클러스터에 여러 개의 노드가 있다면, 차라리 두 개의 pod 로 분리해서 CPU 등 하드웨어 자원을 더 효율적으로 사용할 수 있을 것이다.

더불어 쿠버네티스에서 scaling 의 단위는 pod 이다. 컨테이너 단위로는 복제할 수 없다. (정말? - 확인 필요)

(+ 왜 스케일링의 단위가 컨테이너가 아닌 pod 로 설계했을까? 관련이 깊은 작업들은 묶어서 한꺼번에 스케일링 하기 위해? 각각을 복제하고 묶는 것보다는 나을 것 같긴 하다.)

또한 각 어플리케이션 마다 scaling 을 위한 조건이 다를 수 있다. 프론트/백 모두 한 pod 내에 있었다면 스케일링 했을 경우 프론트/백 모두 2개씩 존재하게 된다. 한편 백엔드의 경우 DB가 있다면 scale out 이 어려울 수 있으며, 경우에 따라서 프론트/백 중 어느 하나만 부하가 심해 하나만 scale out 해야하는 상황이 올 수도 있다.

차라리 이들을 분리하여 각각 하나의 pod 에서 실행되도록 하는 것이 바람직한 방법이다.

#### 어떤 컨테이너들을 한 pod 내에 묶을 것인가

Pod 내에 여러 컨테이너를 넣는다면 그에 합당한 이유가 있어야 한다. 컨테이너가 서로 긴밀하게 연관되어 있어야 한다. Main 컨테이너가 하나 있고 나머지가 해당 컨테이너를 support 한다던가 (sidecar), 혹은 컨테이너들이 하나의 volume 을 공유해야 하는 상황이라던가.

대표적으로 로깅을 담당하는 컨테이너의 경우 (logrotate, 단순 수집, 수집 후 어딘가로 전송) 어플리케이션과 함께 같은 pod 내에 존재하는 것이 나을 것이다.

한 pod 내에 여러 컨테이너를 묶는다면 아래 3가지 질문을 해보면 된다.

- 같이 실행 되어야 하는가? 아니면 다른 호스트에서 실행되어도 괜찮은가?
- 여러 컨테이너가 하나처럼 동작하는가? 아니면 독립적인 컴포넌트인가?
- 함께 스케일링 되어야 하는가? 아니면 따로 스케일링 되어야 하는가?

기본적으로는 pod 를 분리하는 쪽으로 결정하는 것이 바람직하다. 특별한 이유가 없다면!

## 3.2 YAML/JSON 파일로부터 pod 만들기

보통 pod 를 비롯한 쿠버네티스 리소스를 만들 때는 YAML/JSON 파일을 Kubernetes API 에 POST 해서 만든다.

물론 `kubectl run ...` 을 사용할 수 있긴 하지만 모든 옵션을 다 지원하지는 않으며, 매번 명령을 입력하기 보다는 파일로 저장하고 관리하여 버전 관리도 할 수 있게 된다.

### 3.2.1 YAML descriptor

```
$ kubectl get po <POD_NAME> -o yaml
```
- Pod 의 정보를 yaml 형태로 출력하고 싶을 때 사용하는 명령어
- 뒤에 `yaml` 대신에 `json` 을 붙이면 JSON 파일로 출력 결과를 볼 수 있다.

복잡하지만 크게 구성은 다음과 같다.

- 쿠버네티스 API 버전
- 쿠버네티스 object type
- Pod metadata
  - 이름, namespace, 레이블을 비롯한 기타 정보
- Pod specification/contents
  - Pod 내에 존재하는 내용으로 컨테이너, 볼륨과 같은 정보
- Pod status
  - 현재 실행중인 pod 의 상세 정보, 내부 IP 등

### 3.2.2 Pod 을 위한 YAML descriptor 만들기

대략 다음과 같은 내용으로 구성하면 된다.

```yaml
apiVersion: # 쿠버네티스 API 버전
kind: Pod # Pod 임을 명시
metadata:
  name: # Pod 이름
spec:
  container:
  - image: # 컨테이너를 실행할 이미지
    name: # 컨테이너의 이름
    ports: # 컨테이너가 listen 할 포트
    - containerPort:
      protocol: TCP
```

### 3.2.3 `kubectl` 로 pod 생성하기

```
$ kubectl create -f <YAML_FILE>
```
- Argument 로 넘겨준 파일의 설정으로부터 pod 를 생성한다.

생성 후 잘 돌아가는지 확인하려면 `kubectl get pods` 로 확인하면 된다.


### 3.2.4 로그 확인하기

컨테이너 내의 앱은 파일에 로그를 떨구기보다는 보통은 stdout, stderr 로 로그를 내보낸다. 이렇게 하면 다양한 컨테이너들에서 다양한 어플리케이션을 실행할 때 통일된 방법으로 로그를 확인할 수 있다.

```
$ docker logs <CONTAINER_ID>
```
- 컨테이너 내의 로그 (stdout/stderr)를 파일로 redirection 해준다.
- 하지만 `docker` 명령어를 실행하는 것이므로 pod 내에 ssh 로 접근해서 해야한다.

쿠버네티스에서는 더 간편한 방법을 제공해준다.

```
$ kubectl logs <POD_NAME>
```
- 해당 pod 의 로그를 확인할 수 있게 된다.
- Pod 내의 특정 컨테이너 로그를 확인하려면 `-c <CONTAINER_NAME>` 을 붙여주면 된다.
- 컨테이너 로그는 10MB 마다, 매일 rotation 된다.

물론 컨테이너가 삭제되면 로그가 함께 삭제되므로, 클러스터 전체의 로그를 수집하는 부분이 따로 필요하다. (centralized logging) 이는 나중에 17장에서 다룬다.

### 3.2.5 Pod 에 요청 보내기

2장에서 한 것처럼 `kubectl expose` 를 사용하는 방법도 있지만 Service object 에 대해서는 나중에 알아보기로 하고, 포트포워딩으로 하는 방법을 소개한다.

```
$ kubectl port-forward <POD_NAME> <LOCAL_PORT>:<POD_PORT>
```
- 로컬의 포트를 pod 의 포트로 포워딩해준다.
